grammar Mini;

options {
  language = C;
}
@header
{
#include"GRLIST.H"
#include <iostream>
#include<string>
using namespace std;

}
@members{ Graph g(7);
		   int c_o=0;
		  
		}


evaluator:
expression{
      cout<<"start:"<<endl;
	 //cout<<$term.result;
	 g.print();
      }
	  EOF;
              


term returns [string result,string s]:
     identifier{
	 $s.assign($identifier.result);                  // This strange reassignment was done to remove the occuring of some errors(segmentation core)

	 $result.assign($s);
	 } 
      | '(' expression')'  {
	  $s.assign($expression.node);
	 $result.assign($s);
	  }
	  |
      value  {
     $s.assign($value.result);
	 $result.assign($s);
	 }
      //| array 
      //| boole
      //| pair
      
      ; 	  
	  
	  //*****************************************************************************************
	  //*****************************************************************************************
	  //*****************************************************************************************
	  negation returns[string node,string s] @init{bool negation=false;int count=0;}:

('not'{  negation=true;  count++;}
            )* term{
				  $s.assign( $term.result);    // This strange reassignment was done to remove the occuring of some errors
	              $node.assign($s);
				  if(negation)
				  { for(int i=1;i<=count;i++)
                   {g.setEdge(c_o,0,"not" );
				    g.setEdge(c_o,i,$node);
					$node="not";
				   }
				  c_o++; 
				  }
				  
		 }
		 
;
	  

	  
	  //******************************************************************************************
	  //******************************************************************************************
	  //******************************************************************************************
unary returns[string node,string s] @init{bool positive=true;int count=0;}:

('+'|'-'{    count++;
             positive=false;})* negation{
				  $s.assign( $negation.node);    // This strange reassignment was done to remove the occuring of some errors
	              $node.assign($s);
				  if(!positive)
				  {
				   for(int i=1;i<=count;i++)
                   {g.setEdge(c_o,0,"-" );
				    g.setEdge(c_o,i,$node);
					$node="-";
				   }
				  c_o++; 
		 }
		 }
;
	  //*****************************************************************************************
	  //*****************************************************************************************
	  //*****************************************************************************************

mult returns[string node,string s]@init{ bool mul=true,div=true,exp=true,mod=true;int c_m=1,c_d=1,c_e=1,c_mod=1;}:
	op1=unary 
	{$s.assign( $op1.node);
	$node.assign( $s);              //$node=$op1.node
	cout<<"op1"<<endl;
	cout<<$op1.node<<endl;
	
    }
	('*' op2=unary {
	cout<<"op2"<<endl;
	cout<<$op2.node<<endl;
	if(mul){
	g.setEdge(c_o,0,"*" );
	g.setEdge(c_o,c_m,$node );
    c_m++;
	g.setEdge(c_o,c_m,$op2.node );
	$node="*";
	c_o++;
	cout<<$node<<endl;mul=false;}
	else
	{   c_m++;
	g.setEdge(c_o-1,c_m,$op2.node );
       cout<<$node<<endl;}
           }     
         |
	'/' op2=unary {
	cout<<"op2"<<endl;
	cout<<$op2.node<<endl;
	if(div){
	g.setEdge(c_o,0,"/" );
	g.setEdge(c_o,c_d,$node );
    c_d++;
	g.setEdge(c_o,c_d,$op2.node );
	$node="/";
	c_o++;
	cout<<$node<<endl;div=false;}
	else
	{   c_d++;
	g.setEdge(c_o-1,c_d,$op2.node );
       cout<<$node<<endl;}
           }     
|'tothe' op2=unary {
	
	if(exp){
	g.setEdge(c_o,0,"tothe" );
	g.setEdge(c_o,c_e,$node );
    c_e++;
	g.setEdge(c_o,c_e,$op2.node );
	$node="tothe";
	c_o++;
	cout<<$node<<endl;exp=false;}
	else
	{   c_e++;
	g.setEdge(c_o-1,c_e,$op2.node );
       cout<<$node<<endl;}
           }     
  		   
	|
	'mod' op2=unary {
	if(mod){
	g.setEdge(c_o,0,"mod" );
	g.setEdge(c_o,c_mod,$node );
    c_mod++;
	g.setEdge(c_o,c_mod,$op2.node );
	$node="mod";
	c_o++;
	cout<<$node<<endl;mod=false;}
	else
	{   c_mod++;
	g.setEdge(c_o-1,c_mod,$op2.node );
       }
           }     
      )*
       ;   
        
	  //*****************************************************************************************
	  //*****************************************************************************************
	  //*****************************************************************************************

addmult returns [string node,string s]   @init{bool add=true,sub=true;int c_na=1,c_ns=1;int temp_a=0;int temp_s=0;int replace_a=0,replace_s=0;}:   
    op1=mult{
	$s.assign( $op1.node);
	$node.assign($s);
	cout<<"op1_m"<<endl;
	cout<<$node<<endl;	
	
    }
	('+'op2=mult{                   
                   if(add)
                   {
				   
				   cout<<c_o<<endl;
                   g.setEdge(c_o,0,"+" );                               
                   g.setEdge(c_o,c_na,$node );
				   c_na++;

				   g.setEdge(c_o,c_na,$op2.node );
				   $node="+";
                   c_o++;
				                     
				   add=false;					  // note that c_n is the index of an operand starting from 1
                   replace_a=c_o;                 // store the value of c_o to replace_a so that we don't increment c_o in the else expression
				   }
                  else  
                  { 
				  temp_a++;		                   // temp_a is used to count the number of time this operator occurs after the first one,ie how many (pluses-1) I have in the given expression
			      c_na++;
				 
					   g.setEdge(replace_a-temp_a,c_na,$op2.node );
					   replace_a++;}
                    }  
					
		
			  | '-'op2=mult{  if(sub)
                   {
				   cout<<"sub"<<endl<<c_ns<<endl;
				   g.setEdge(c_o,0,"-" );                               
                   g.setEdge(c_o,c_ns,$node );
				   c_ns++;
				   g.setEdge(c_o,c_ns,$op2.node );
				   $node="-";
                   
				   c_o++;
				   
				   sub=false;
				   replace_s=c_o;
                   }
                  else  
                  { 
				  temp_s++;
				  c_ns++;
				  g.setEdge(replace_s-temp_s,c_ns,$op2.node );
                    replace_s++;} 
					}
	     	     )*
      ;
	  //*****************************************************************************************
	  //*****************************************************************************************
	  //*****************************************************************************************

	 comparision  returns [string node,string s]   @init{bool lt=true,gt=true,eq,neq,lte,gte=true;int c_lt=1,c_gt=1,c_eq=1,c_neq=1,c_lte=1,c_gte=1;int temp_lt=0;int temp_gt=0,temp_eq=0,temp_neq=0,temp_lte=0,temp_gte=0;int replace_lt=0,replace_gt=0,replace_lte,replace_gte,replace_eq,replace_neq=0;} : 
	  op1=addmult 
	  { 
	  	$s.assign( $op1.node);
	    $node.assign($s);
	     
	  }
	  
	  
	  (
	  'lt' op2=addmult 
	  {
	  if(lt)
                   {
				   cout<<c_o<<endl;
                   g.setEdge(c_o,0,"lt" );                               
                   g.setEdge(c_o,c_lt,$node );
				   c_lt++;
				   g.setEdge(c_o,c_lt,$op2.node );
				   $node="lt";
                   c_o++;
 
				   lt=false;					  // note that c_n is the index of an operand starting from 1
                   replace_lt=c_o;
				   }
                  else  
                  { 
				  temp_lt++;		                   // temp_a is used to count the number of time this operator occurs after the first one,ie how many (pluses-1) I have in the given expression
			      
				 c_lt++;
				 
					   g.setEdge(replace_lt-temp_lt,c_lt,$op2.node );
					   replace_lt++;
					   }
                    }  
					
			|
			
				  'gt' op2=addmult 
	  {
	  if(gt)
                   {
				  
                   g.setEdge(c_o,0,"gt" );                               
                   g.setEdge(c_o,c_gt,$node );
				   c_gt++;
				   g.setEdge(c_o,c_gt,$op2.node );
				   $node="gt";
                   c_o++;
 
				   gt=false;					  // note that c_n is the index of an operand starting from 1
                   replace_gt=c_o;
				   }
                  else  
                  { 
				  temp_gt++;		                   // temp_a is used to count the number of time this operator occurs after the first one,ie how many (pluses-1) I have in the given expression
			      
				 c_gt++;
				 
					   g.setEdge(replace_gt-temp_gt,c_gt,$op2.node );
					   replace_gt++;
					   }
                    }  
                |
				 'eq' op2=addmult 
	  {
				if(eq)
                   {
				  
                   g.setEdge(c_o,0,"eq" );                               
                   g.setEdge(c_o,c_eq,$node );
				   c_eq++;
				   g.setEdge(c_o,c_eq,$op2.node );
				   $node="eq";
                   c_o++;
 
				   eq=false;					  // note that c_n is the index of an operand starting from 1
                   replace_eq=c_o;
				   }
                  else  
                  { 
				  temp_eq++;		                   // temp_a is used to count the number of time this operator occurs after the first one,ie how many (pluses-1) I have in the given expression
			      
				 c_eq++;
				 
					   g.setEdge(replace_eq-temp_eq,c_eq,$op2.node );
					   replace_eq++;
					   }
                    }  
			|
			 'neq' op2=addmult 
	  {
			if(neq)
                   {
				  
                   g.setEdge(c_o,0,"neq" );                               
                   g.setEdge(c_o,c_neq,$node );
				   c_neq++;
				   g.setEdge(c_o,c_neq,$op2.node );
				   $node="neq";
                   c_o++;
 
				   neq=false;					  // note that c_n is the index of an operand starting from 1
                   replace_neq=c_o;
				   }
                  else  
                  { 
				  temp_neq++;		                   // temp_a is used to count the number of time this operator occurs after the first one,ie how many (pluses-1) I have in the given expression
			      
				 c_neq++;
				 
					   g.setEdge(replace_neq-temp_neq,c_neq,$op2.node );
					   replace_neq++;
					   }
                    }  
					
					
					 |
					 'lte' op2=addmult 
	  {
			if(lte)
                   {
				  
                   g.setEdge(c_o,0,"lte" );                               
                   g.setEdge(c_o,c_lte,$node );
				   c_lte++;
				   g.setEdge(c_o,c_lte,$op2.node );
				   $node="lte";
                   c_o++;
 
				   lte=false;					  // note that c_n is the index of an operand starting from 1
                   replace_lte=c_o;
				   }
                  else  
                  { 
				  temp_lte++;		                   // temp_a is used to count the number of time this operator occurs after the first one,ie how many (pluses-1) I have in the given expression
			      
				 c_lte++;
				 
					   g.setEdge(replace_lte-temp_lte,c_lte,$op2.node );
					   replace_lte++;
					   }
                    }  
					 
					 
					 |
					 'gte' op2=addmult 
	  {
			if(gte)
                   {
				  
                   g.setEdge(c_o,0,"gte" );                               
                   g.setEdge(c_o,c_gte,$node );
				   c_gte++;
				   g.setEdge(c_o,c_gte,$op2.node );
				   $node="gte";
                   c_o++;
 
				   gte=false;					  // note that c_n is the index of an operand starting from 1
                   replace_gte=c_o;
				   }
                  else  
                  { 
				  temp_gte++;		                   // temp_a is used to count the number of time this operator occurs after the first one,ie how many (pluses-1) I have in the given expression
			      
				 c_gte++;
				 
					   g.setEdge(replace_gte-temp_gte,c_gte,$op2.node );
					   replace_gte++;
					   }
                    }  
	  
	  
	  )*
      ;
	  //*****************************************************************************************
	  //*****************************************************************************************
	  //*****************************************************************************************
	  
	  expression returns [string node,string s]   @init{bool andd=true,orr=true,xorr=true;int c_and=1,c_or=1,c_xor=1;int temp_and=0;int temp_or=0,temp_xor=0;int replace_and=0,replace_or=0,replace_xor=0;} : 
	  op1=comparision 
	  { 
	  	$s.assign( $op1.node);
	    $node.assign($s);
	     
	  }
	  
	  ('and' op2=comparision 
	  {
	  if(andd)
                   {
				   cout<<c_o<<endl;
                   g.setEdge(c_o,0,"and" );                               
                   g.setEdge(c_o,c_and,$node );
				   c_and++;
				   g.setEdge(c_o,c_and,$op2.node );
				   $node="and";
                   c_o++;
				   andd=false;					  
                   replace_and=c_o;
				   }
                  else  
                  { 
				  temp_and++;		                   // temp_and is used to count the number of time this operator occurs after the first one,ie how many (pluses-1) I have in the given expression
			      
				  c_and++;
			          g.setEdge(replace_and-temp_and,c_and,$op2.node );                   
                   
					   replace_and++;
					   }
                    }  
	 
	  |
	  'xor' op2=comparision 
	  {
	  if(xorr)
                   {
				   cout<<c_o<<endl;
                   g.setEdge(c_o,0,"xor" );                               
                   g.setEdge(c_o,c_xor,$node );
				   c_xor++;
				   g.setEdge(c_o,c_xor,$op2.node );
				   $node="xor";
                   c_o++;
				   xorr=false;					  
                   replace_xor=c_o;
				   }
                  else  
                  { 
				  temp_xor++;		                   // temp_and is used to count the number of time this operator occurs after the first one,ie how many (pluses-1) I have in the given expression
			      
				  c_xor++;
			          g.setEdge(replace_xor-temp_xor,c_xor,$op2.node );                   
                   
					   replace_xor++;
					   }
                    }  
	   |
	  'or' op2=comparision 
	  {
	  if(orr)
                   {
				   cout<<c_o<<endl;
                   g.setEdge(c_o,0,"or" );                               
                   g.setEdge(c_o,c_or,$node );
				   c_or++;
				   g.setEdge(c_o,c_or,$op2.node );
				   $node="or";
                   c_o++;
				   orr=false;					  
                   replace_or=c_o;
				   }
                  else  
                  { 
				  temp_or++;		                   // temp_and is used to count the number of time this operator occurs after the first one,ie how many (pluses-1) I have in the given expression
			      
				  c_or++;
			          g.setEdge(replace_or-temp_or,c_or,$op2.node );                   
                   
					   replace_or++;
					   }
                    }  
	  
	  
	  )*
      ;

 
element : paire | vecteur | value | boole|identifier;

  paire  : ('{' ( element ) ',' (element) '}')
      ;
  vecteur   : ('[' (element ) (',' (element))* ']')  | (identifier ('[' (element ) (',' (element))* ']'))
      ;
  value  returns [string result,string s] : 
(INTEGER{  
 uint8_t *widget; 	  	  
 widget = ($INTEGER.text->chars); 
 $s.append(1,*widget);
 $result.assign($s); 
 }                
 )+
      ;
  boole   : 'true' | 'false'
      ;

identifier returns[string result,string s]:

L0=LETTER{
 uint8_t *widget; 	  
 widget = ($L0.text->chars); 
 $s.append(1,*widget);
 $result.assign($s); }
 
 (L1=LETTER{
 uint8_t *widget; 	  
 widget = ($L1.text->chars); 
 $s.append(1,*widget);
 $result.assign($s); 
 }
   INTEGER{
 uint8_t *widget; 	  
 widget = ($INTEGER.text->chars); 
 $s.append(1,*widget);
 $result.assign($s); 
 }
   )*
  ;

INTEGER : ('0'..'9');

LETTER:('a'..'z'|'A'..'Z');

WS : (' '|'\r'|'\t'|'\u000C'|'\n' | 'f')+ {$channel = HIDDEN;};
#include    "MiniLexer.h"
#include<iostream>
#include<string>
#include    "MiniParser.h"
#include "WovenGraph.h"
#include "test_module.h"
#include "GraphAdapter.h"
#include "Translator.h"

typedef ProgGraph<string,string> GraphZ;
/**\var structure
 *\brief The Graph that will be used when parsing the input file
 */
void DFS();
Graph structure;
GraphZ ZaGraph;
class MyVisitor 
{
	
public:
	bool operator() (GraphZ::ProgNode * node) 
	{
		cout << "node " << node->data << endl;
		
		
		return true;
	}
	bool operator() (GraphZ::ProgEdge * edge) 
	{
		cout << "Edge" << " from " << edge->from.data << " to " << edge->to.data << endl;
		return true;
	}
};


int ANTLR3_CDECL main        (int argc, char *argv[])
{
	
	ifstream infile,infile1;

	Translator Diplomat;
    pANTLR3_UINT8            fName;

    pANTLR3_INPUT_STREAM    input;

    // The lexer is of course generated by ANTLR, and so the lexer type is not upper case.
    // The lexer is supplied with a pANTLR3_INPUT_STREAM from whence it consumes its
    // input and generates a token stream as output.
    //
    pMiniLexer                    lxr;

    pANTLR3_COMMON_TOKEN_STREAM            tstream;

    pMiniParser                                psr;

    // Create the input stream based upon the argument supplied to us on the command line
    // for this example, the input will always default to ./input if there is no explicit
    // argument.
    //
	
	int a= 0;

    if (argc < 2 || argv[1] == NULL)
    {
				 cout << "" << endl;
		 cout << "1-Parse input program" << endl;
		 cout <<"2-Parse assignments and check if values in test/module.txt are consistent" << endl;
		cout << "3-Parse input program, translate graph to ProgGraph and traverse ProgGraph" << endl; 
		 cin >> a;
         if ( a== 1 || a==3)
		 {
			fName        =(pANTLR3_UINT8)"../input/input.txt"; 
		 }
		else if ( a==2 )
		 {
			fName        =(pANTLR3_UINT8)"../input/TestInputModule.txt"; 
			 infile.open("../tests/module.txt");
			 infile1.open("../input/TestInputModule.txt");
		 }
		
	 }
    else
    {
                fName        = (pANTLR3_UINT8)argv[1];
    }

    input        = antlr3AsciiFileStreamNew(fName);
	
    if ( input == NULL)
    {
            fprintf(stderr, "Failed to open file %s\n", (char *)fName);
                exit(1);
        }


    lxr            = MiniLexerNew(input);
    //
    if ( lxr == NULL )
    {

            fprintf(stderr, "Unable to create the lexer due to malloc() failure1\n");
            exit(1);

    }


        tstream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));

    if (tstream == NULL)
    {
        fprintf(stderr, "Out of memory trying to allocate token stream\n");
        exit(1);
    }

    	psr            = MiniParserNew(tstream);
	 
    if (psr == NULL)
    {
        fprintf(stderr, "Out of memory trying to allocate parser\n");
        exit(ANTLR3_ERR_NOMEM);
    }

    psr->pStructure(psr);

	structure.DFS(structure.findNodeByName("Begin"));
	
	
	
	if (a==3)
	{
		Diplomat.translatetoZ(structure,ZaGraph);
		DFS();
		Diplomat.ConvertZ(ZaGraph,structure);
	}
	
	
	if (a==2)
	{
	test x; 
	x.read_module(infile); 
	string takes;  
	int AssCounter = 0;
	while(true) 
	{
		
		getline(infile1,takes);
		string TTakes = "takes";
		if (takes.find(TTakes) != string::npos )
		{
			AssCounter++;
		}
		else if (takes.find("end") != string::npos)
		{
			break;
		} 
		
		
	}
	
	
	
	for(int i=0;i<AssCounter;i++)
	{x.set_test();
		x.clear(); 
		if(x.check) cout<< "The assignment of "<< x.variable<<" is consistent with the program"<<endl;
		else cout<<"The assignment of "<<x.incorrect_ass<<" is not consistent with the program: the variable "<<x.incorrect_ass<< " has the caclulated value equal to :"<<
			x.calculated_value<<" and assigned value of: "<<x.incorrect_value<<endl; 
		
	}
	
	}

    psr            ->free  (psr);            psr = NULL;
    tstream ->free  (tstream);            tstream = NULL;
    lxr            ->free  (lxr);            lxr = NULL;
    input   ->close (input);            input = NULL;

    return 0;
}

void DFS()
{
	
	MyVisitor LetsVisit;
	GraphZ::DFTraverse<MyVisitor> DepthFirst(LetsVisit,1);
	DepthFirst(ZaGraph);
}

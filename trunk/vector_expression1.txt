grammar Mini;

options {
  language = C;
}
@preincludes
{
#include"GRAPH.H"
#include <iostream>
#include<string>
using namespace std;

}



@members{  Graph exp; 
		   int c_o=0;
		  
		  
		}


evaluator:
expression{
      cout<<"start:"<<endl;
	 //cout<<$term.result;
	 exp.displayGraph();
      }
	  EOF;
              

term returns [string node,string s]:
     identifier{
	 $s.assign($identifier.result);                  // This strange reassignment was done to remove the occuring of some errors(segmentation core)

	 $node.assign($s);
	 } 
    /*  | '(' expression')'  {
	$s.assign($expression.node);
	 $node.assign($s);
	  }
	  */
	  |
      value  {
     $s.assign($value.result);
	 $node.assign($s);
	 }
      //| array 
      //| boole
      //| pair
      
      ; 	  
	  //*****************************************************************************************
	  //*****************************************************************************************
	  //*****************************************************************************************
 
 negation returns[string node,string s] @init{bool negation=false;int count=0;}:

('not'{  negation=true;  count++;}
            )* term{
				  $s.assign( $term.node);    // This strange reassignment was done to remove the occuring of some errors
	              $node.assign($s);          //node=term.node
				  if(negation)
				  { for(int i=1;i<=count;i++)
                   {
				   Node* neg=new Node("not");
				   exp.addNewNode(neg);
				   Node* a=new Node($node);
				   exp.addNewNode(a);
				   (*neg).addAdjNode(a,1);
				   $node="not";
				 
				   }
				 
				  }
				  
		 }
		 
;
 
 
 
 
 
  //*****************************************************************************************
	  //*****************************************************************************************
	  //*****************************************************************************************
 
unary returns[string node,string s] @init{bool positive=true; int count=0;}:
('+'|'-'{    count++;
             positive=false;})* negation{
				  $s.assign( $negation.node);    // This strange reassignment was done to remove the occuring of some errors
	              $node.assign($s);
				  if(!positive)
				  {
				   for(int i=1;i<=count;i++)
                   {
				   Node* unary=new Node("-");
				   exp.addNewNode(unary);
				   Node* a=new Node($node);
				   exp.addNewNode(a);
				   (*unary).addAdjNode(a,1);
				   $node="-";
				   }
			}
		 }
;

//*****************************************************************************************
	  //*****************************************************************************************
	  //*****************************************************************************************
mult returns[string node,string s]@init{ bool mul=true,div=true,ex=true,mod=true;Node* expon=new Node("tothe");Node* divide=new Node("/");Node* mult=new Node("*");Node* modulo=new Node("mod");}:  //;int c_m=1,c_d=1,c_e=1,c_mod=1;}:
	op1=unary 
	
	{$s.assign( $op1.node);
	 $node.assign($s);              //$node=$op1.node
		
    }
 
	('*' op2=unary
	{
	
	if(mul){
	
    exp.addNewNode(mult);
	Node*b=new Node($node);
	exp.addNewNode(b);
	Node*c=new Node($op2.node);
	exp.addNewNode(c);
	(*mult).addAdjNode(b,1);
	(*mult).addAdjNode(c,1);
	$node="*";
	mul=false;
		}
	
	else{
	Node*b=new Node($op2.node);
	exp.addNewNode(b);
	(*mult).addAdjNode(b,1);
	}
	}
	
	| '/' op2=unary
	{
	
	if(div){
	
    exp.addNewNode(divide);
	Node*b=new Node($node);
	exp.addNewNode(b);
	Node*c=new Node($op2.node);
	exp.addNewNode(c);
	(*divide).addAdjNode(b,1);
	(*divide).addAdjNode(c,1);
	$node="/";
	div=false;
		}
	
	else{
	Node*b=new Node($op2.node);
	exp.addNewNode(b);
	(*divide).addAdjNode(b,1);
	}
	}
	| 'tothe' op2=unary
	{
	
	if(ex){
	
    exp.addNewNode(expon);
	Node*b=new Node($node);
	exp.addNewNode(b);
	Node*c=new Node($op2.node);
	exp.addNewNode(c);
	(*expon).addAdjNode(b,1);
	(*expon).addAdjNode(c,1);
	$node="tothe";
	ex=false;
		}
	
	else{
	Node*b=new Node($op2.node);
	exp.addNewNode(b);
	(*expon).addAdjNode(b,1);
	}
	}
	
	
	| 'mod' op2=unary
	{
	
	if(mod){
	
    exp.addNewNode(modulo);
	Node*b=new Node($node);
	exp.addNewNode(b);
	Node*c=new Node($op2.node);
	exp.addNewNode(c);
	(*modulo).addAdjNode(b,1);
	(*modulo).addAdjNode(c,1);
	$node="mod";
	mod=false;
		}
	
	else{
	Node*b=new Node($op2.node);
	exp.addNewNode(b);
	(*modulo).addAdjNode(b,1);
	}
	}
	
)*

;


 //*****************************************************************************************
 //*****************************************************************************************
 //*****************************************************************************************


addmult returns [string node,string s]   @init{bool add=true,sub=true;Node* ad=new Node("+");Node* substrat=new Node("-");}://;int c_na=1,c_ns=1;int temp_a=0;int temp_s=0;int replace_a=0,replace_s=0;}:   
    op1=mult{
	$s.assign( $op1.node);
	$node.assign($s);
	cout<<"op1_m"<<endl;
	cout<<$node<<endl;	
	
    }
('+'op2=mult{                   
    if(add){
	
	exp.addNewNode(ad);
	Node*b=new Node($node);
	exp.addNewNode(b);
	Node*c=new Node($op2.node);
	exp.addNewNode(c);
	(*ad).addAdjNode(b,1);
	(*ad).addAdjNode(c,1);
	$node="+";
	add=false;
				   
				   }
else{

    Node*b=new Node($op2.node);
	exp.addNewNode(b);
	(*ad).addAdjNode(b,1);}
				   }
				   
	
| '-' op2=mult
{                   
    if(sub){
	
	exp.addNewNode(substrat);
	Node*b=new Node($node);
	exp.addNewNode(b);
	Node*c=new Node($op2.node);
	exp.addNewNode(c);
	(*substrat).addAdjNode(b,1);
	(*substrat).addAdjNode(c,1);
	$node="-";
	sub=false;
				   
				   }
else{

    Node*b=new Node($op2.node);
	exp.addNewNode(b);
	(*substrat).addAdjNode(b,1);}
				   }
				)*
;
//*****************************************************************************************
//*****************************************************************************************
//*****************************************************************************************



comparision  returns [string node,string s]   @init{bool lt=true,lte=true,gt=true,eq=true,neq=true,gte=true;Node* greater_e=new Node("gte");Node* less_e=new Node("lte");Node* nequal=new Node("neq");Node* equal=new Node("eq");Node* less=new Node("lt");Node* greater=new Node("gt");}://lte,gte=true;int c_lt=1,c_gt=1,c_eq=1,c_neq=1,c_lte=1,c_gte=1;int temp_lt=0;int temp_gt=0,temp_eq=0,temp_neq=0,temp_lte=0,temp_gte=0;int replace_lt=0,replace_gt=0,replace_lte,replace_gte,replace_eq,replace_neq=0;} : 
	  op1=addmult 
	  { 
	  	$s.assign( $op1.node);
	    $node.assign($s);
	     
	  }
	  (
	  'lt' op2=addmult 
	  {
	  if(lt){
	exp.addNewNode(less);
	Node*b=new Node($node);
	exp.addNewNode(b);
	Node*c=new Node($op2.node);
	exp.addNewNode(c);
	(*less).addAdjNode(b,1);
	(*less).addAdjNode(c,1);
	$node="lt";
	less=false;
	}
	else{
	Node*b=new Node($op2.node);
	exp.addNewNode(b);
	(*less).addAdjNode(b,1);
	}
	  }
	 
	 | 
	'gt' op2=addmult 
	  {
	  if(gt){
	exp.addNewNode(greater);
	Node*b=new Node($node);
	exp.addNewNode(b);
	Node*c=new Node($op2.node);
	exp.addNewNode(c);
	(*greater).addAdjNode(b,1);
	(*greater).addAdjNode(c,1);
	$node="gt";
	gt=false;
	}
	else{
	Node*b=new Node($op2.node);
	exp.addNewNode(b);
	(*greater).addAdjNode(b,1);
	}
	  }
	  
	  |
	  
	  'eq' op2=addmult 
	  {
	  if(eq){
	exp.addNewNode(equal);
	Node*b=new Node($node);
	exp.addNewNode(b);
	Node*c=new Node($op2.node);
	exp.addNewNode(c);
	(*equal).addAdjNode(b,1);
	(*equal).addAdjNode(c,1);
	$node="eq";
	eq=false;
	}
	else{
	Node*b=new Node($op2.node);
	exp.addNewNode(b);
	(*equal).addAdjNode(b,1);
	}
	  }
	  |
	  
	  'neq' op2=addmult 
	  {
	  if(neq){
	exp.addNewNode(nequal);
	Node*b=new Node($node);
	exp.addNewNode(b);
	Node*c=new Node($op2.node);
	exp.addNewNode(c);
	(*nequal).addAdjNode(b,1);
	(*nequal).addAdjNode(c,1);
	$node="neq";
	neq=false;
	}
	else{
	Node*b=new Node($op2.node);
	exp.addNewNode(b);
	(*nequal).addAdjNode(b,1);
	}
	  }
	  |
	  
	  
	  'lte' op2=addmult 
	  {
	  if(lte){
	exp.addNewNode(less_e);
	Node*b=new Node($node);
	exp.addNewNode(b);
	Node*c=new Node($op2.node);
	exp.addNewNode(c);
	(*less_e).addAdjNode(b,1);
	(*less_e).addAdjNode(c,1);
	$node="lte";
	lte=false;
	}
	else{
	Node*b=new Node($op2.node);
	exp.addNewNode(b);
	(*less_e).addAdjNode(b,1);
	}
	  }
	  
	  |
	  
	  'gte' op2=addmult 
	  {
	  if(gte){
	exp.addNewNode(greater_e);
	Node*b=new Node($node);
	exp.addNewNode(b);
	Node*c=new Node($op2.node);
	exp.addNewNode(c);
	(*greater_e).addAdjNode(b,1);
	(*greater_e).addAdjNode(c,1);
	$node="gte";
	gte=false;
	}
	else{
	Node*b=new Node($op2.node);
	exp.addNewNode(b);
	(*greater_e).addAdjNode(b,1);
	}
	  }
	  
	  
	  )*
;





expression returns [string node,string s]   @init{bool andd=true,xorr=true,orr=true;Node* o=new Node("or");Node* x=new Node("xor");Node* an=new Node("and");}://,xorr=true;int c_and=1,c_or=1,c_xor=1;int temp_and=0;int temp_or=0,temp_xor=0;int replace_and=0,replace_or=0,replace_xor=0;} : 


op1=comparision 
	  { 
	  	$s.assign( $op1.node);
	    $node.assign($s);
	     
	  }
	  
	  ('and' op2=comparision 
	  {
	  if(andd){
	  
	  
    exp.addNewNode(an);
	Node*b=new Node($node);
	exp.addNewNode(b);
	Node*c=new Node($op2.node);
	exp.addNewNode(c);
	(*an).addAdjNode(b,1);
	(*an).addAdjNode(c,1);
	$node="and";
	andd=false;}
	
	else{
	
	Node*b=new Node($op2.node);
	exp.addNewNode(b);
	(*an).addAdjNode(b,1);}
	  }
	  
	 |
	 
	 'or' op2=comparision 
	  {
	  if(orr){
	  
	  
    exp.addNewNode(o);
	Node*b=new Node($node);
	exp.addNewNode(b);
	Node*c=new Node($op2.node);
	exp.addNewNode(c);
	(*o).addAdjNode(b,1);
	(*o).addAdjNode(c,1);
	$node="or";
	orr=false;}
	
	else{
	
	Node*b=new Node($op2.node);
	exp.addNewNode(b);
	(*o).addAdjNode(b,1);}
	  }
	  
	  |
	 
	 'xor' op2=comparision 
	  {
	  if(xorr){
	  
	  
    exp.addNewNode(x);
	Node*b=new Node($node);
	exp.addNewNode(b);
	Node*c=new Node($op2.node);
	exp.addNewNode(c);
	(*x).addAdjNode(b,1);
	(*x).addAdjNode(c,1);
	$node="xor";
	xorr=false;}
	
	else{
	
	Node*b=new Node($op2.node);
	exp.addNewNode(b);
	(*x).addAdjNode(b,1);}
	  }
	 
	  )*
;











element : paire | vecteur | value | boole|identifier;

  paire  : ('{' ( element ) ',' (element) '}')
      ;
  vecteur   : ('[' (element ) (',' (element))* ']')  | (identifier ('[' (element ) (',' (element))* ']'))
      ;
  value  returns [string result,string s] : 
(INTEGER{  
 uint8_t *widget; 	  	  
 widget = ($INTEGER.text->chars); 
 $s.append(1,*widget);
 $result.assign($s); 
 }                
 )+
      ;
  boole   : 'true' | 'false'
      ;

identifier returns[string result,string s]:

L0=LETTER{
 uint8_t *widget; 	  
 widget = ($L0.text->chars); 
 $s.append(1,*widget);
 $result.assign($s); }
 
 (L1=LETTER{
 uint8_t *widget; 	  
 widget = ($L1.text->chars); 
 $s.append(1,*widget);
 $result.assign($s); 
 }
   INTEGER{
 uint8_t *widget; 	  
 widget = ($INTEGER.text->chars); 
 $s.append(1,*widget);
 $result.assign($s); 
 }
   )*
  ;

INTEGER : ('0'..'9');

LETTER:('a'..'z'|'A'..'Z');

WS : (' '|'\r'|'\t'|'\u000C'|'\n' | 'f')+ {$channel = HIDDEN;};